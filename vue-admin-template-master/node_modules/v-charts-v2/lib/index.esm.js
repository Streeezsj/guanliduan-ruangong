import echarts from 'echarts/lib/echarts';
import 'echarts/lib/component/tooltip';
import 'echarts/lib/component/legend';
import numeral from 'numeral';
import 'echarts/lib/chart/line';

var getStackMap = function getStackMap(stack) {
  var stackMap = {};
  Object.keys(stack).forEach(function (item) {
    stack[item].forEach(function (name) {
      stackMap[name] = item;
    });
  });
  return stackMap;
};

var getType = function getType(v) {
  return Object.prototype.toString.call(v);
};

var clone = function clone(v) {
  return JSON.parse(JSON.stringify(v));
};

var toKebab = function toKebab(v) {
  return v.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
};

var isArray = function isArray(v) {
  return getType(v) === '[object Array]';
};

var isObject = function isObject(v) {
  return getType(v) === '[object Object]';
};

var isFunction = function isFunction(v) {
  return typeof v === 'function';
};

var getFnAndObjValue = function getFnAndObjValue(target, key) {
  return isFunction(target) ? target(key) : !isObject(target) ? key : target[key] != null ? target[key] : key;
};

var getFormat = function getFormat(v, format) {
  var defaultValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '-';

  if (v == null) return defaultValue;
  return format ? numeral(v).format(format) : v;
};

var arrDelItem = function arrDelItem(arr, item) {
  var result = clone(arr);
  var index = arr.indexOf(item);
  result.splice(index, 1);
  return result;
};

var arrDelArrItem = function arrDelArrItem(arr, diffArr) {
  return arr.filter(function (item) {
    return !~diffArr.indexOf(item);
  });
};

var optionsAddAttr = function optionsAddAttr(obj, target, item) {
  if (!target) return;
  if (isObject(target)) {
    Object.keys(target).forEach(function (key) {
      optionsAddAttr(obj, key, target[key]);
    });
    return;
  }
  if (obj[target] && isArray(obj[target])) {
    if (isArray(item)) {
      obj[target] = obj[target].concat(item);
    } else {
      obj[target].push(item);
    }
  } else {
    if (isArray(item)) {
      obj[target] = item;
    } else {
      obj[target] = [item];
    }
  }
};

var debounce = function debounce(fn, delay) {
  var timer = null;
  return function () {
    var self = this;
    var args = arguments;
    clearTimeout(timer);
    timer = setTimeout(function () {
      fn.apply(self, args);
    }, delay);
  };
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

function getXAxis(args) {
  var dimension = args.dimension,
      rows = args.rows,
      gridIndex = args.gridIndex,
      xAxisType = args.xAxisType,
      xAxisName = args.xAxisName,
      axisVisible = args.axisVisible;


  return {
    type: xAxisType,
    name: xAxisName,
    data: rows.map(function (row) {
      return { value: row[dimension] };
    }),
    show: axisVisible,
    gridIndex: gridIndex
  };
}

function getYAxis(args) {
  var rightMetrics = args.rightMetrics,
      leftMetrics = args.leftMetrics,
      yAxisType = args.yAxisType,
      metricsType = args.metricsType,
      axisVisible = args.axisVisible,
      scale = args.scale,
      min = args.min,
      max = args.max,
      gridIndex = args.gridIndex,
      yAxisName = args.yAxisName;

  var yAxis = [];
  var yAxisBase = {
    type: 'value',
    show: axisVisible,
    gridIndex: gridIndex
  };
  var types = [yAxisType[0] || metricsType[leftMetrics[0]], yAxisType[1] || metricsType[rightMetrics[0]]];

  var _loop = function _loop(i) {
    if (!i || i && rightMetrics) {
      yAxis[i] = _extends({}, yAxisBase, {
        name: yAxisName[i] || '',
        scale: scale[i] || false,
        min: min[i] || null,
        max: max[i] || null
      });
      if (types[i]) {
        yAxis[i].axisLabel = {
          formatter: function formatter(val) {
            return getFormat(val, types[i]);
          }
        };
      }
    }
  };

  for (var i = 0; i < 2; i++) {
    _loop(i);
  }
  return yAxis;
}

function getSeries(args) {
  var rows = args.rows,
      leftMetrics = args.leftMetrics,
      rightMetrics = args.rightMetrics,
      extraMetrics = args.extraMetrics,
      stack = args.stack,
      labelAlias = args.labelAlias,
      dimension = args.dimension,
      displayMetrics = args.displayMetrics,
      metricsType = args.metricsType,
      yAxisType = args.yAxisType,
      area = args.area;

  var stackMap = stack && getStackMap(stack);
  var series = [];

  displayMetrics.forEach(function (metricsItem, index) {
    var data = [];
    rows.forEach(function (row) {
      var value = {
        value: [row[dimension], row[metricsItem]],
        _extra: [],
        name: row[dimension],
        format: metricsType[metricsItem] || ~leftMetrics.indexOf(metricsItem) && yAxisType[0] || ~rightMetrics.indexOf(metricsItem) && yAxisType[1] || false
      };
      if (index === displayMetrics.length - 1) {
        extraMetrics.forEach(function (ext) {
          value._extra.push({
            name: row[dimension],
            seriesName: ext,
            value: [row[dimension], row[ext]],
            format: metricsType[ext] || false
          });
        });
      }
      data.push(value);
    });
    series.push({
      name: getFnAndObjValue(labelAlias, metricsItem),
      type: 'line',
      data: data,
      yAxisIndex: ~leftMetrics.indexOf(metricsItem) ? 0 : 1, // TODO: 处理多图时的坐标轴问题，
      xAxisIndex: 0,
      stack: stack && stackMap[metricsItem],
      areaStyle: area && { normal: {} }
    });
  });

  return series;
}

var line = function line(options, columns, rows, settings, extra) {
  var _settings$dimension = settings.dimension,
      dimension = _settings$dimension === undefined ? columns[0] : _settings$dimension,
      customMetrics = settings.metrics,
      _settings$extraMetric = settings.extraMetrics,
      extraMetrics = _settings$extraMetric === undefined ? [] : _settings$extraMetric,
      _settings$axisSite = settings.axisSite,
      axisSite = _settings$axisSite === undefined ? {} : _settings$axisSite,
      _settings$gridIndex = settings.gridIndex,
      gridIndex = _settings$gridIndex === undefined ? 0 : _settings$gridIndex,
      _settings$xAxisType = settings.xAxisType,
      xAxisType = _settings$xAxisType === undefined ? 'category' : _settings$xAxisType,
      _settings$xAxisName = settings.xAxisName,
      xAxisName = _settings$xAxisName === undefined ? '' : _settings$xAxisName,
      _settings$yAxisType = settings.yAxisType,
      yAxisType = _settings$yAxisType === undefined ? [] : _settings$yAxisType,
      _settings$yAxisName = settings.yAxisName,
      yAxisName = _settings$yAxisName === undefined ? [] : _settings$yAxisName,
      _settings$metricsType = settings.metricsType,
      metricsType = _settings$metricsType === undefined ? {} : _settings$metricsType,
      labelAlias = settings.labelAlias,
      legendAlias = settings.legendAlias,
      tooltipAlias = settings.tooltipAlias,
      _settings$scale = settings.scale,
      scale = _settings$scale === undefined ? [] : _settings$scale,
      _settings$stack = settings.stack,
      stack = _settings$stack === undefined ? {} : _settings$stack,
      _settings$min = settings.min,
      min = _settings$min === undefined ? [] : _settings$min,
      _settings$max = settings.max,
      max = _settings$max === undefined ? [] : _settings$max,
      area = settings.area;
  var axisVisible = extra.axisVisible;

  var metrics = customMetrics || arrDelItem(columns, dimension);
  var rightMetrics = axisSite.right || [];
  var leftMetrics = axisSite.left || arrDelArrItem(metrics, rightMetrics);
  var displayMetrics = leftMetrics.concat(rightMetrics);
  var xAxis = getXAxis({
    dimension: dimension,
    rows: rows,
    gridIndex: gridIndex,
    xAxisType: xAxisType,
    xAxisName: xAxisName,
    axisVisible: axisVisible
  });
  var yAxis = getYAxis({
    rightMetrics: rightMetrics,
    leftMetrics: leftMetrics,
    yAxisType: yAxisType,
    metricsType: metricsType,
    axisVisible: axisVisible,
    scale: scale,
    min: min,
    max: max,
    gridIndex: gridIndex,
    yAxisName: yAxisName
  });
  var series = getSeries({
    rows: rows,
    leftMetrics: leftMetrics,
    rightMetrics: rightMetrics,
    extraMetrics: extraMetrics,
    stack: stack,
    labelAlias: labelAlias,
    dimension: dimension,
    displayMetrics: displayMetrics,
    metricsType: metricsType,
    yAxisType: yAxisType,
    area: area
  });
  var _legendSettings = {
    legendAlias: legendAlias,
    displayMetrics: displayMetrics,
    labelAlias: labelAlias
  };
  var _tooltipSettings = {
    trigger: 'axis',
    tooltipAlias: tooltipAlias
  };
  optionsAddAttr(options, {
    xAxis: xAxis,
    yAxis: yAxis,
    series: series,
    _legendSettings: _legendSettings,
    _tooltipSettings: _tooltipSettings
  });
  return options;
};

var COLORS = ['#19d4ae', '#5ab1ef', '#fa6e86', '#ffb980', '#0067a6', '#c4b4e4', '#d87a80', '#9cbbff', '#d9d0c7', '#87a997', '#d49ea2', '#5b4947', '#7ba3a8'];

var DEFAULT_THEME = {
  categoryAxis: {
    axisLine: { show: false },
    axisTick: { show: false },
    splitLine: { show: false }
  },
  valueAxis: {
    axisLine: { show: false },
    axisTick: { show: false }
  },
  line: {
    smooth: true
  },
  grid: {
    containLabel: true,
    left: 10,
    right: 10
  }
};

var NO_DATA_LOGIC_PROPS = ['initOptions', 'loading', 'dataEmpty', 'judgeWidth', 'widthChangeDelay'];

var Loading = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "v-charts-component-loading" }, [_c('div', { staticClass: "loader" }, [_c('div', { staticClass: "loading-spinner" }, [_c('svg', { staticClass: "circular", attrs: { "viewBox": "25 25 50 50" } }, [_c('circle', { staticClass: "path", attrs: { "cx": "50", "cy": "50", "r": "20", "fill": "none" } })])])])]);
  }, staticRenderFns: []
};

var DataEmpty = { render: function render() {
    var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "v-charts-data-empty" }, [_vm._v(" 暂无数据 ")]);
  }, staticRenderFns: []
};

function setExtendOptions(options, extend) {
  // extend sub attribute
  Object.keys(extend).forEach(function (attr) {
    if (typeof extend[attr] === 'function') {
      // get callback value
      options[attr] = extend[attr](options[attr]);
    } else {
      // mixin extend value
      if (isArray(options[attr]) && isObject(options[attr][0])) {
        // eg: [{ xx: 1 }, { xx: 2 }]
        options[attr].forEach(function (option, index) {
          options[attr][index] = _extends({}, option, extend[attr]);
        });
      } else if (isObject(options[attr])) {
        // eg: { xx: 1, yy: 2 }
        options[attr] = _extends({}, options[attr], extend[attr]);
      } else {
        options[attr] = extend[attr];
      }
    }
  });
}

function setTooltip(options) {
  var _options$_tooltipSett = options._tooltipSettings,
      _tooltipSettings = _options$_tooltipSett === undefined ? {} : _options$_tooltipSett;

  var trigger = 'item';
  var tooltipAlias = null;
  _tooltipSettings.forEach(function (tooltipItem) {
    var customTrigger = tooltipItem.trigger,
        customTooltipAlias = tooltipItem.tooltipAlias;

    if (customTrigger) trigger = customTrigger;
    if (customTooltipAlias) tooltipAlias = customTooltipAlias;
  });
  options.tooltip = {
    show: true,
    trigger: trigger,
    formatter: function formatter(items) {
      var tpl = [];
      var title = getFnAndObjValue(tooltipAlias, items[0].name);
      tpl.push(title);
      items.forEach(function (item) {
        var _item$data = item.data,
            format = _item$data.format,
            value = _item$data.value,
            _extra = _item$data._extra,
            seriesName = item.seriesName,
            marker = item.marker;

        var val = value.length ? value[1] : value;
        tpl.push('' + marker + seriesName + ': ' + getFormat(val, format));
        if (_extra && _extra.length) {
          _extra.forEach(function (extraItem) {
            var value = extraItem.value,
                format = extraItem.format,
                seriesName = extraItem.seriesName;

            var val = value.length ? value[1] : value;
            tpl.push('' + marker + seriesName + ': ' + getFormat(val, format));
          });
        }
      });
      return tpl.join('<br>');
    }
  };
}

function setMarks(seriesItem, marks) {
  Object.keys(marks).forEach(function (key) {
    if (marks[key]) seriesItem[key] = marks[key];
  });
}

function setLegend(options) {
  var legend = void 0;
  var settings = options._legendSettings[0];
  var displayMetrics = settings.displayMetrics,
      legendAlias = settings.legendAlias,
      labelAlias = settings.labelAlias;

  if (!legendAlias && !labelAlias) legend = { data: displayMetrics };
  var data = labelAlias ? displayMetrics.map(function (item) {
    return getFnAndObjValue(labelAlias, item);
  }) : displayMetrics;
  legend = [{
    data: data,
    formatter: function formatter(name) {
      return getFnAndObjValue(legendAlias, name);
    }
  }];
  options.legend = legend;
}

var Core = {
  render: function render(h) {
    return h('div', {
      class: [toKebab(this.$options.name || this.$options._componentTag)],
      style: this.canvasStyle
    }, [h('div', {
      style: this.canvasStyle,
      ref: 'canvas'
    }), h(Loading, {
      style: { display: this.loading ? '' : 'none' }
    }), h(DataEmpty, {
      style: { display: this.dataEmpty ? '' : 'none' }
    }), this.$slots.default]);
  },


  props: {
    // custom props
    data: { type: [Object, Array], default: function _default() {
        return {};
      }
    },
    settings: { type: Object, default: function _default() {
        return {};
      }
    },

    width: { type: String, default: 'auto' },
    height: { type: String, default: '400px' },

    beforeConfig: Function,
    afterConfig: Function,
    afterSetOption: Function,
    afterSetOptionOnce: Function,

    events: Object,

    initOptions: { type: Object, default: function _default() {
        return {};
      }
    },

    tooltipVisible: { type: Boolean, default: true },
    legendVisible: { type: Boolean, default: true },
    axisVisible: { type: Boolean, default: true },

    markLine: Object,
    markArea: Object,
    markPoint: Object,

    theme: Object,
    themeName: String,

    loading: Boolean,
    dataEmpty: Boolean,

    extend: Object,

    judgeWidth: { type: Boolean, default: false },
    widthChangeDelay: { type: Number, default: 300 },

    resizeable: { type: Boolean, default: true },
    resizeDelay: { type: Number, default: 200 },

    changeDelay: { type: Number, default: 0 },

    handler: { type: Object, default: function _default() {
        return {};
      }
    },
    useDataConverter: Boolean,
    // echarts props
    grid: [Object, Array],
    colors: Array,
    visualMap: [Object, Array],
    dataZoom: [Object, Array],
    toolbox: [Object, Array],
    title: Object,
    legend: [Object, Array],
    xAxis: [Object, Array],
    yAxis: [Object, Array],
    radar: Object,
    tooltip: Object,
    axisPointer: Object,
    brush: [Object, Array],
    geo: Object,
    timeline: [Object, Array],
    graphic: [Object, Array],
    series: [Object, Array],
    backgroundColor: [Object, String],
    textStyle: Object,
    animation: Object
  },

  watch: {
    data: {
      deep: true,
      handler: function handler(v) {
        if (v) this.changeHandler();
      }
    },

    settings: {
      deep: true,
      handler: function handler(v) {
        if (v) this.changeHandler();
      }
    },

    events: {
      deep: true,
      handler: function handler() {
        this.createEventProxy();
      }
    },

    theme: {
      deep: true,
      handler: function handler(v) {
        this.themeChange(v);
      }
    },

    themeName: function themeName(v) {
      this.themeChange(v);
    }
  },

  computed: {
    canvasStyle: function canvasStyle() {
      return {
        width: this.width,
        height: this.height,
        position: 'relative'
      };
    },
    chartColor: function chartColor() {
      return this.colors || this.theme && this.theme.color || COLORS;
    }
  },

  methods: {
    init: function init() {
      if (this.echarts) return;
      var themeArg = this.themeName || this.theme || DEFAULT_THEME;
      this.echarts = this.echartsLib.init(this.$refs.canvas, themeArg, this.initOptions);
      if (this.data) this.changeHandler();
      this.createEventProxy();
      if (this.resizeable) window.addEventListener('resize', this.resizeHandler);
    },
    dataHandler: function dataHandler() {
      var dataConverter = this.handler.dataConverter;
      var data = this.data;

      var options = {};

      if (!this.chartHandler) return;
      if (this.useDataConverter && dataConverter) data = dataConverter(data);
      if (this.beforeConfig) data = this.beforeConfig(data);

      var _data = data,
          _data$columns = _data.columns,
          columns = _data$columns === undefined ? [] : _data$columns,
          _data$rows = _data.rows,
          rows = _data$rows === undefined ? [] : _data$rows;


      options = this.chartHandler(options, columns, rows, this.settings, {
        axisVisible: this.axisVisible,
        echarts: this.echarts
      });

      if (options) {
        if (typeof options.then === 'function') {
          options.then(this.optionsHandler);
        } else {
          this.optionsHandler(options);
        }
      }
    },
    optionsHandler: function optionsHandler(options) {
      var _this = this;

      var animation = this.animation,
          echarts$$1 = this.echarts,
          _once = this._once;

      if (this.tooltipVisible) setTooltip(options);
      if (this.legendVisible) setLegend(options);
      // add echarts origin options attributes
      var echartsAttrs = ['grid', 'dataZoom', 'visualMap', 'toolbox', 'title', 'legend', 'xAxis', 'yAxis', 'radar', 'tooltip', 'axisPointer', 'brush', 'geo', 'timeline', 'graphic', 'series', 'backgroundColor', 'textStyle'];
      echartsAttrs.forEach(function (setting) {
        if (_this[setting] != null) options[setting] = _this[setting];
      });

      // add animation related to echarts options
      if (animation) {
        Object.keys(animation).forEach(function (key) {
          options[key] = animation[key];
        });
      }
      // add mark* to echarts series
      if (this.markArea || this.markLine || this.markPoint) {
        var marks = {
          markArea: this.markArea,
          markLine: this.markLine,
          markPoint: this.markPoint
        };
        var series = options.series;
        if (isArray(series)) {
          series.forEach(function (item) {
            setMarks(item, marks);
          });
        } else if (isObject(series)) {
          setMarks(series, marks);
        }
      }

      options.color = this.chartColor;

      if (this.extend) setExtendOptions(options, this.extend);

      if (this.afterConfig) options = this.afterConfig(options);
      echarts$$1.setOption(options, true);

      if (this.judgeWidth) this.judgeWidthHandler(options);

      this.$emit('ready', echarts$$1);
      if (!_once['ready-once']) {
        _once['ready-once'] = true;
        this.$emit('ready-once', echarts$$1);
      }

      if (this.afterSetOption) this.afterSetOption(echarts$$1);
      if (this.afterSetOptionOnce && !_once['afterSetOptionOnce']) {
        _once['afterSetOptionOnce'] = true;
        this.afterSetOptionOnce(echarts$$1);
      }
    },
    judgeWidthHandler: function judgeWidthHandler(options) {
      var _this2 = this;

      var echarts$$1 = this.echarts;


      if (this.$el.clientWidth) {
        echarts$$1 && echarts$$1.resize();
      } else {
        this.$nextTick(function (_) {
          if (_this2.$el.clientWidth) {
            echarts$$1 && echarts$$1.resize();
          } else {
            setTimeout(function (_) {
              echarts$$1 && echarts$$1.resize();
              if (!_this2.$el.clientWidth) {
                console.warn(' Can\'t get dom width or height ');
              }
            }, _this2.widthChangeDelay);
          }
        });
      }
    },
    resize: function resize() {
      this.echarts.resize();
    },
    addWatchToProps: function addWatchToProps() {
      var _this3 = this;

      var watchedVariable = this._watchers.map(function (watcher) {
        return watcher.expression;
      });
      Object.keys(this.$props).forEach(function (prop) {
        if (!~watchedVariable.indexOf(prop) && !~NO_DATA_LOGIC_PROPS.indexOf(prop)) {
          var opts = {};
          var item = _this3.$props[prop];
          if (isObject(item) || isArray(item)) opts.deep = true;
          _this3.$watch(prop, _this3.changeHandler, opts);
        }
      });
    },
    createEventProxy: function createEventProxy() {
      var _this4 = this;

      var self = this;
      var keys = Object.keys(this.events || {});
      keys.length && keys.forEach(function (ev) {
        if (_this4.registeredEvents.indexOf(ev) === -1) {
          _this4.registeredEvents.push(ev);
          _this4.echarts.on(ev, function (ev) {
            return function () {
              if (ev in self.events) {
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                self.events[ev].apply(null, args);
              }
            };
          }(ev));
        }
      });
    },
    themeChange: function themeChange(theme) {
      this.clean();
      this.echarts = null;
      this.init();
    },
    clean: function clean() {
      if (this.resizeable) {
        window.removeEventListener('resize', this.resizeHandler);
      }
      this.echarts.dispose();
    }
  },

  created: function created() {
    var _this5 = this;

    this.echarts = null;
    this.registeredEvents = [];
    this._once = {};
    this.resizeHandler = debounce(function (_) {
      _this5.echarts && _this5.echarts.resize();
    }, this.resizeDelay);
    this.changeHandler = debounce(function (_) {
      _this5.dataHandler();
    }, this.changeDelay);
    this.addWatchToProps();
  },
  mounted: function mounted() {
    this.init();
  },
  beforeDestroy: function beforeDestroy() {
    this.clean();
  }
};

var VeLine = {
  name: 'VeLine',
  mixins: [Core],
  created: function created() {
    this.chartHandler = line;
    this.echartsLib = echarts;
  }
};

/* eslint-disable comma-dangle */
// import VeBar from './packages/bar'
// import VeHistogram from './packages/histogram'
// import VePie from './packages/pie'
// import VeRing from './packages/ring'
// import VeWaterfall from './packages/waterfall'
// import VeFunnel from './packages/funnel'
// import VeRadar from './packages/radar'
// import VeChart from './packages/chart'
// import VeMap from './packages/map'
// import VeBmap from './packages/bmap'
// import VeAmap from './packages/amap'
// import VeSankey from './packages/sankey'
// import VeHeatmap from './packages/heatmap'
// import VeScatter from './packages/scatter'
// import VeCandle from './packages/candle'
// import VeGauge from './packages/gauge'
// import VeTree from './packages/tree'

var components = [VeLine];

function install(Vue, _) {
  components.forEach(function (component) {
    Vue.component(component.name, component);
  });
}

export { VeLine, install };
